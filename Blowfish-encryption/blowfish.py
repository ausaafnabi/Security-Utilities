			
                        	[
				0x3A39CE37, 0xD3FAF5CF, 0xABC27737, 0x5AC52D1B,
				0x5CB0679E, 0x4FA33742, 0xD3822740, 0x99BC9BBE,
				0xD5118E9D, 0xBF0F7315, 0xD62D1C7E, 0xC700C47B,
				0xB78C1B6B, 0x21A19045, 0xB26EB1BE, 0x6A366EB4,
				0x5748AB2F, 0xBC946E79, 0xC6A376D2, 0x6549C2C8,
				0x530FF8EE, 0x468DDE7D, 0xD5730A1D, 0x4CD04DC6,
				0x2939BBDB, 0xA9BA4650, 0xAC9526E8, 0xBE5EE304,
				0xA1FAD5F0, 0x6A2D519A, 0x63EF8CE2, 0x9A86EE22,
				0xC089C2B8, 0x43242EF6, 0xA51E03AA, 0x9CF2D0A4,
				0x83C061BA, 0x9BE96A4D, 0x8FE51550, 0xBA645BD6,
				0x2826A2F9, 0xA73A3AE1, 0x4BA99586, 0xEF5562E9,
				0xC72FEFD3, 0xF752F7DA, 0x3F046F69, 0x77FA0A59,
				0x80E4A915, 0x87B08601, 0x9B09E6AD, 0x3B3EE593,
				0xE990FD5A, 0x9E34D797, 0x2CF0B7D9, 0x022B8B51,
				0x96D5AC3A, 0x017DA67D, 0xD1CF3ED6, 0x7C7D2D28,
				0x1F9F25CF, 0xADF2B89B, 0x5AD6B472, 0x5A88F54C,
				0xE029AC71, 0xE019A5E6, 0x47B0ACFD, 0xED93FA9B,
				0xE8D3C48D, 0x283B57CC, 0xF8D56629, 0x79132E28,
				0x785F0191, 0xED756055, 0xF7960E44, 0xE3D35E8C,
				0x15056DD4, 0x88F46DBA, 0x03A16125, 0x0564F0BD,
				0xC3EB9E15, 0x3C9057A2, 0x97271AEC, 0xA93A072A,
				0x1B3F6D9B, 0x1E6321F5, 0xF59C66FB, 0x26DCF319,
				0x7533D928, 0xB155FDF5, 0x03563482, 0x8ABA3CBB,
				0x28517711, 0xC20AD9F8, 0xABCC5167, 0xCCAD925F,
				0x4DE81751, 0x3830DC8E, 0x379D5862, 0x9320F991,
				0xEA7A90C2, 0xFB3E7BCE, 0x5121CE64, 0x774FBE32,
				0xA8B6E37E, 0xC3293D46, 0x48DE5369, 0x6413E680,
				0xA2AE0810, 0xDD6DB224, 0x69852DFD, 0x09072166,
				0xB39A460A, 0x6445C0DD, 0x586CDECF, 0x1C20C8AE,
				0x5BBEF7DD, 0x1B588D40, 0xCCD2017F, 0x6BB4E3BB,
				0xDDA26A7E, 0x3A59FF45, 0x3E350A44, 0xBCB4CDD5,
				0x72EACEA8, 0xFA6484BB, 0x8D6612AE, 0xBF3C6F47,
				0xD29BE463, 0x542F5D9E, 0xAEC2771B, 0xF64E6370,
				0x740E0D8D, 0xE75B1357, 0xF8721671, 0xAF537D5D,
				0x4040CB08, 0x4EB4E2CC, 0x34D2466A, 0x0115AF84,
				0xE1B00428, 0x95983A1D, 0x06B89FB4, 0xCE6EA048,
				0x6F3F3B82, 0x3520AB82, 0x011A1D4B, 0x277227F8,
				0x611560B1, 0xE7933FDC, 0xBB3A792B, 0x344525BD,
				0xA08839E1, 0x51CE794B, 0x2F32C9B7, 0xA01FBAC9,
				0xE01CC87E, 0xBCC7D1F6, 0xCF0111C3, 0xA1E8AAC7,
				0x1A908749, 0xD44FBD9A, 0xD0DADECB, 0xD50ADA38,
				0x0339C32A, 0xC6913667, 0x8DF9317C, 0xE0B12B4F,
				0xF79E59B7, 0x43F5BB3A, 0xF2D519FF, 0x27D9459C,
				0xBF97222C, 0x15E6FC2A, 0x0F91FC71, 0x9B941525,
				0xFAE59361, 0xCEB69CEB, 0xC2A86459, 0x12BAA8D1,
				0xB6C1075E, 0xE3056A0C, 0x10D25065, 0xCB03A442,
				0xE0EC6E0E, 0x1698DB3B, 0x4C98A0BE, 0x3278E964,
				0x9F1F9532, 0xE0D392DF, 0xD3A0342B, 0x8971F21E,
				0x1B0A7441, 0x4BA3348C, 0xC5BE7120, 0xC37632D8,
				0xDF359F8D, 0x9B992F2E, 0xE60B6F47, 0x0FE3F11D,
				0xE54CDA54, 0x1EDAD891, 0xCE6279CF, 0xCD3E7E6F,
				0x1618B166, 0xFD2C1D05, 0x848FD2C5, 0xF6FB2299,
				0xF523F357, 0xA6327623, 0x93A83531, 0x56CCCD02,
				0xACF08162, 0x5A75EBB5, 0x6E163697, 0x88D273CC,
				0xDE966292, 0x81B949D0, 0x4C50901B, 0x71C65614,
				0xE6C6C7BD, 0x327A140A, 0x45E1D006, 0xC3F27B9A,
				0xC9AA53FD, 0x62A80F00, 0xBB25BFE2, 0x35BDD2F6,
				0x71126905, 0xB2040222, 0xB6CBCF7C, 0xCD769C2B,
				0x53113EC0, 0x1640E3D3, 0x38ABBD60, 0x2547ADF0,
				0xBA38209C, 0xF746CE76, 0x77AFA1C5, 0x20756060,
				0x85CBFE4E, 0x8AE88DD8, 0x7AAAF9B0, 0x4CF9AA7E,
				0x1948C25C, 0x02FB8A8C, 0x01C36AE4, 0xD6EBE1F9,
				0x90D4F869, 0xA65CDEA0, 0x3F09252D, 0xC208E69F,
				0xB74E6132, 0xCE77E25B, 0x578FDFE3, 0x3AC372E6
			]
		]


# Cycle through the p-boxes and round-robin XOR the
		# key with the p-boxes
		key_len = len (key)
		index = 0
		for i in range (len (self.p_boxes)):
			val = ((key[index % key_len]) << 24) + \
			      ((key[(index + 1) % key_len]) << 16) + \
			      ((key[(index + 2) % key_len]) << 8) + \
			       (key[(index + 3) % key_len])
			self.p_boxes[i] = self.p_boxes[i] ^ val
			index = index + 4

		# For the chaining process
		l, r = 0, 0

		# Begin chain replacing the p-boxes
		for i in range (0, len (self.p_boxes), 2):
			l, r = self.cipher (l, r, self.ENCRYPT)
			self.p_boxes[i] = l
			self.p_boxes[i + 1] = r

		# Chain replace the s-boxes
		for i in range (len (self.s_boxes)):
			for j in range (0, len (self.s_boxes[i]), 2):
				l, r = self.cipher (l, r, self.ENCRYPT)
				self.s_boxes[i][j] = l
				self.s_boxes[i][j + 1] = r

	def cipher (self, xl, xr, direction):

		if direction == self.ENCRYPT:
			for i in range (16):
				xl = xl ^ self.p_boxes[i]
				xr = self.__round_func (xl) ^ xr
				xl, xr = xr, xl
			xl, xr = xr, xl
			xr = xr ^ self.p_boxes[16]
			xl = xl ^ self.p_boxes[17]
		else:
			for i in range (17, 1, -1):
				xl = xl ^ self.p_boxes[i]
				xr = self.__round_func (xl) ^ xr
				xl, xr = xr, xl
			xl, xr = xr, xl
			xr = xr ^ self.p_boxes[1]
			xl = xl ^ self.p_boxes[0]
		return xl, xr

	def __round_func (self, xl):
		a = (xl & 0xFF000000) >> 24
		b = (xl & 0x00FF0000) >> 16
		c = (xl & 0x0000FF00) >> 8
		d = xl & 0x000000FF

		# Perform all ops as longs then and out the last 32-bits to
		# obtain the integer
		f = (int (self.s_boxes[0][a]) + int (self.s_boxes[1][b])) % self.modulus
		f = f ^ int (self.s_boxes[2][c])
		f = f + int (self.s_boxes[3][d])
		f = (f % self.modulus) & 0xFFFFFFFF

		return f

	def encrypt (self, data):

		if not len (data) == 8:
			raise RuntimeError("Attempted to encrypt data of invalid block length: %s" %len (data))

		# Use big endianess since that's what everyone else uses
		xl = ord (data[3]) | (ord (data[2]) << 8) | (ord (data[1]) << 16) | (ord (data[0]) << 24)
		xr = ord (data[7]) | (ord (data[6]) << 8) | (ord (data[5]) << 16) | (ord (data[4]) << 24)

		cl, cr = self.cipher (xl, xr, self.ENCRYPT)
		chars = ''.join ([
			chr ((cl >> 24) & 0xFF), chr ((cl >> 16) & 0xFF), chr ((cl >> 8) & 0xFF), chr (cl & 0xFF),
			chr ((cr >> 24) & 0xFF), chr ((cr >> 16) & 0xFF), chr ((cr >> 8) & 0xFF), chr (cr & 0xFF)
		])
		return chars

	def decrypt (self, data):

		if not len (data) == 8:
			raise RuntimeError("Attempted to encrypt data of invalid block length: %s" %len (data))

		# Use big endianess since that's what everyone else uses
		cl = (data[3]) | ((data[2]) << 8) | ((data[1]) << 16) | ((data[0]) << 24)
		cr = (data[7]) | ((data[6]) << 8) | ((data[5]) << 16) | ((data[4]) << 24)

		xl, xr = self.cipher (cl, cr, self.DECRYPT)
		chars = bytes ([
			((xl >> 24) & 0xFF), ((xl >> 16) & 0xFF), ((xl >> 8) & 0xFF), (xl & 0xFF),
			((xr >> 24) & 0xFF), ((xr >> 16) & 0xFF), ((xr >> 8) & 0xFF), (xr & 0xFF)
		])
		return chars

	def blocksize (self):
		return 8

	def key_length (self):
		return 56

	def key_bits (self):
		return 56 * 8

##############################################################
# Module testing

if __name__ == '__main__':
	key = 'This is a test key'
	cipher = Blowfish (key)

	print("Testing encryption:")
	xl = 123456
	xr = 654321
	print("\tPlain text: (%s, %s)" %(xl, xr))
	cl, cr = cipher.cipher (xl, xr, cipher.ENCRYPT)
	print("\tCrypted is: (%s, %s)" %(cl, cr))
	dl, dr = cipher.cipher (cl, cr, cipher.DECRYPT)
	print("\tUnencrypted is: (%s, %s)" %(dl, dr))

	print("Testing buffer encrypt:")
	text = 'testtest'
	print("\tText: %s" %text)
	crypted = cipher.encrypt (text)
	print("\tEncrypted: %s" %crypted)
	decrypted = cipher.decrypt (crypted)
	print("\tDecrypted: %s" %decrypted)
